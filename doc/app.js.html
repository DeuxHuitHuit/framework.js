<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: app.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: app.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Superlight App Framework
 *
 * @fileoverview Defines the App Mediator
 *
 * @author Deux Huit Huit &lt;https://deuxhuithuit.com>
 * @license MIT &lt;https://deuxhuithuit.mit-license.org>
 *
 * @requires jQuery
 * @namespace App
 */
(function ($, global, undefined) {
	
	'use strict';
	
	//Default value
	var ROOT = 'body';
	
	/** Mediator **/
	var mediatorIsLoadingPage = false;
	var currentRouteUrl = document.location.href.substring(
		document.location.protocol.length + 2 + document.location.host.length
	);
	
	//Store ref to the current page object
	var currentPage = null;
	
	//Store ref to the previous page object
	var previousPage = null;
	var previousUrl = '';
	
	/**
	 * Find and execute the methods that matches with the notify key
	 * @name _callAction
	 * @memberof App
	 * @method
	 * @param {Function|Object} actions Object of methods that can be matches with the key's value
	 * @param {String} key Action key
	 * @param {Object} data Bag of data
	 * @returns {Boolean} Callback's result
	 * @private
	 */
	var _callAction = function (actions, key, data) {
		if ($.isFunction(actions)) {
			actions = actions();
		}
		if (!!actions) {
			var tempFx = actions[key];
			
			if (!$.isFunction(tempFx) &amp;&amp; !!~key.indexOf('.')) {
				tempFx = actions;
				// try JSONPath style...
				var paths = key.split('.');
				$.each(paths, function eachPath () {
					tempFx = tempFx[this];
					if (!$.isPlainObject(tempFx)) {
						return false; // exit
					}
					return true;
				});
			}
			
			return App.callback(tempFx, [key, data]);
		}
	};
	
	/**
	 * Scope the _callAction actions only for the current page
	 * @name notifyCurrentPage
	 * @memberof App
	 * @method
	 * @param {String} key Notify key
	 * @param {Object} data Bag of data
	 * @param {Function} cb Callback executed after all the _callAction are executed
	 * @this {Object} Mediator
	 * @returns this
	 * @public
	 */
	var notifyPage = function (key, data, cb) {
		if (!!currentPage) {
			if ($.isFunction(data) &amp;&amp; !cb) {
				cb = data;
				data = undefined;
			}
			var res = App._callAction(currentPage.actions, key, data);
			if (res !== undefined) {
				App.callback(cb, [currentPage.key(), res]);
			}
		}
		return this;
	};
	
	/**
	 * Check if the mediator is loading a page
	 * @name _validateMediatorState
	 * @memberof App
	 * @method
	 * @returns {Boolean}
	 * @private
	 */
	var _validateMediatorState = function () {
		if (mediatorIsLoadingPage) {
			App.log({args: 'Mediator is busy waiting for a page load.', fx: 'error'});
		}
		
		return !mediatorIsLoadingPage;
	};
	
	/**
	 * Check if the page is valid or not
	 * @name _validateNextPage
	 * @memberof App
	 * @method
	 * @param {Object} nextPage PageObject
	 * @returns {Boolean}
	 * @private
	 */
	var _validateNextPage = function (nextPage) {
		var result = true;
			
		if (!nextPage) {
			result = false;
		}
		
		return result;
	};
	
	/**
	 * Check if we can enter the next page
	 * @name _canEnterNextPage
	 * @memberof App
	 * @method
	 * @param {Object} nextPage Next page instence
	 * @returns {Boolean}
	 * @private
	 */
	var _canEnterNextPage = function (nextPage) {
		var result = true;
		
		if (!nextPage.canEnter()) {
			App.log('Cannot enter page %s.', nextPage.key());
			result = false;
		}
		
		return result;
	};
	
	/**
	 * Check if we can leave the current page
	 * @name _canLeaveCurrentPage
	 * @memberof App
	 * @method
	 * @returns {Boolean}
	 * @private
	 */
	var _canLeaveCurrentPage = function () {
		var result = false;
		
		if (!currentPage) {
			App.log({args: 'No current page set.', fx: 'error'});
		} else if (!currentPage.canLeave()) {
			App.log('Cannot leave page %s.', currentPage.key());
		} else {
			result = true;
		}
		
		return result;
	};
	
	//Actions

	/**
	 * Notify all registered component and page
	 * @name notify
	 * @memberof App
	 * @method
	 * @param {String} key Notify key
	 * @param {Object} data Object passed to notified methods
	 * @param {Function} cb Callback executed when the notify is done
	 * @this Mediator
	 * @returns this
	 * @see AER in http://addyosmani.com/largescalejavascript/
	 * @public
	 */
	var notifyAll = function (key, data, cb) {
		
		// propagate action to current page only
		notifyPage(key, data, cb);
		
		// propagate action to all modules
		App.modules.notify(key, data, cb);
		
		return this;
	};

	/**
	 * Change the current page to the requested route
	 * Do nothing if the current page is already the requested route
	 * @name goto
	 * @memberof App
	 * @method 
	 * @param {String} obj Page requested
	 * @param {String} previousPoppedUrl Url
	 * @fires App#page:leave
	 * @fires App#page:enter
	 * @fires App#pages:failedtoparse
	 * @fires App#pages:requestPageTransition
	 * @fires App#page:leaving
	 * @fires App#page:entering
	 * @this App
	 */
	var gotoPage = function (obj, previousPoppedUrl) {
		var nextPage;
		var route = '';
		
		/**
		 * Try to parse the data in jQuery to be sure it's valid
		 * @param {String} data response data
		 * @returns {jQuery}
		 */
		var safeParseData = function (data) {
			try {
				return $(data);
			}
			catch (ex) {
				App.log({args: [ex.message], fx: 'error'});
				/**
				 * @event App#pages:failedtoparse
				 * @type {object}
				 * @property {object} data
				 * @property {string} route
				 * @property {object} nextPage PageObject
				 * @property {object} currentPage PageObject
				 */
				App.modules.notify('pages.failedtoparse', {
					data: data,
					route: route,
					nextPage: nextPage,
					currentPage: currentPage
				});
			}
			return $();
		};
		
		/**
		 * Initiate the transition and leave/enter page logic
		 */
		var enterLeave = function () {
			//Keep currentPage pointer for the callback in a new variable
			//The currentPage pointer will be cleared after the next call
			var leavingPage = currentPage;
			
			/**
			 * Block all interaction with the framework and notify the page leave
			 */
			var leaveCurrent = function () {
				currentPage = null; // clean currentPage pointer,this will block all interactions
				
				//set leaving page to be previous one
				previousPage = leavingPage;
				previousUrl = !!previousPoppedUrl ? previousPoppedUrl :
					document.location.href.substring(
						document.location.protocol.length + 2 + document.location.host.length
					);
				//clear leavingPage
				leavingPage = null;
				
				/**
				 * @event App#page:leave
				 * @type {object}
				 * @property {object} page PageObject
				 */
				App.modules.notify('page.leave', {page: previousPage});
			};
			
			/**
			 * Set the current page to the new one
			 */
			var enterNext = function () {
				// set the new Page as the current one
				currentPage = nextPage;
				
				/**
				 * @event App#page:enter
				 * @type {object}
				 * @property {object} page PageObject
				 */
				App.modules.notify('page.enter', {page: nextPage, route: route});
				// Put down the flag since we are finished
				mediatorIsLoadingPage = false;
			};
			
			var pageTransitionData = {
				currentPage: currentPage,
				nextPage: nextPage,
				leaveCurrent: leaveCurrent,
				enterNext: enterNext,
				route: route,
				isHandled: false
			};
			
			/**
			 * @event App#pages:requestPageTransition
			 * @type {object}
			 * @property {object} pageTransitionData
			 */
			App.modules.notify('pages.requestPageTransition', pageTransitionData);
			
			if (!nextPage.isInited) {
				nextPage.init();
				nextPage.isInited = true;
			}
			
			//if not, return to classic code
			if (!pageTransitionData.isHandled) {
				//Leave to page the transition job
				
				/**
				 * @event App#page:leaving
				 * @type {object}
				 * @property {object} page PageObject
				 */
				App.modules.notify('page.leaving', {page: leavingPage});
				
				//Leave the current page
				leavingPage.leave(leaveCurrent);
				
				/**
				 * @event App#page:entering
				 * @type {object}
				 * @property {object} page PageObject
				 * @property {string} route url
				 */
				App.modules.notify('page.entering', {page: nextPage, route: route});
				
				nextPage.enter(enterNext);
			}
		};
		
		/**
		 * Verify that the data is valid an append the loadded content inside the App's root
		 * @param {String} data requested data
		 * @param {String} textStatus Current request status
		 * @param {Object} jqXHR request instence
		 */
		var loadSucess = function (data, textStatus, jqXHR) {
			var htmldata = safeParseData(data);
			
			// get the node
			var node = htmldata.find(nextPage.key());
			
			// get the root node
			var elem = $(ROOT);
			
			// Check for redirects
			var responseUrl = htmldata.find(ROOT + ' > [data-response-url]')
				.attr('data-response-url');
			
			if (!!responseUrl &amp;&amp; responseUrl != obj.split('#')[0]) {
				
				var redirectedPage = nextPage;
				
				// Find the right page
				nextPage = App.pages.getPageForRoute(responseUrl);
				
				// Offer a bail out door
				App.modules.notify('pages.redirected', {
					currentPage: currentPage,
					nextPage: nextPage,
					redirectedPage: redirectedPage,
					requestedRoute: route,
					responseRoute: responseUrl
				});
				
				// Cancel current transition
				App.modules.notify('pages.requestCancelPageTransition', {
					currentPage: currentPage,
					nextPage: nextPage,
					route: route
				});
				
				if (!_validateNextPage(nextPage)) {
					App.modules.notify('pages.routeNotFound', {
						page: currentPage,
						url: obj,
						isRedirect: true
					});
					App.log({args: ['Redirected route "%s" was not found.', obj], fx: 'error'});
					return;
				} else {
					node = htmldata.find(nextPage.key());
					if (nextPage === currentPage) {
						App.modules.notify('pages.navigateToCurrent', {
							page: nextPage,
							route: route,
							isRedirect: true
						});
						App.log('redirected next page is the current one');
					} else {
						// Start new transition
						App.modules.notify('pages.requestBeginPageTransition', {
							currentPage: currentPage,
							nextPage: nextPage,
							route: responseUrl,
							isRedirect: true
						});
						
					}
				}
			}
			
			if (!node.length) {
				
				App.log({args: ['Could not find "%s" in xhr data.', nextPage.key()], fx: 'error'});
				
				// free the mediator
				mediatorIsLoadingPage = false;
				
				// notify
				App.modules.notify('pages.notfound', {
					data: data,
					url: obj,
					xhr: jqXHR,
					status: textStatus
				});
				
			} else {
				
				// append it to the doc, hidden
				elem.append(node.css({opacity: 0}));
				
				// init page
				nextPage.init();
				nextPage.isInited = true;
				
				node.hide();
				
				App.modules.notify('pages.loaded', {
					elem: elem,
					data: data,
					url: obj,
					page: nextPage,
					node: node,
					xhr: jqXHR,
					status: textStatus
				});
				
				// actual goto
				enterLeave();
			}
		};
		
		/**
		 * Disptch a notify for the progress' event
		 * @name progress
		 * @method
		 * @memberof App
		 * @private
		 * @param {Event} e Request progess event
		 */
		var progress = function (e) {
			var total = e.originalEvent.total;
			var loaded = e.originalEvent.loaded;
			var percent = total > 0 ? loaded / total : 0;

			App.mediator.notify('pages.loadprogress', {
				event: e,
				url: obj,
				total: total,
				loaded: loaded,
				percent: percent
			});
		};
		
		if (_validateMediatorState() &amp;&amp; _canLeaveCurrentPage()) {
			if ($.type(obj) === 'string') {
				nextPage = App.pages.getPageForRoute(obj);
				route = obj;
			} else {
				nextPage = obj;
			}
			
			if (!_validateNextPage(nextPage)) {
				App.modules.notify('pages.routeNotFound', {
					page: currentPage,
					url: obj
				});
				App.log({args: ['Route "%s" was not found.', obj], fx: 'error'});
			} else {
				if (_canEnterNextPage(nextPage)) {
					if (nextPage === currentPage) {
						App.modules.notify('pages.navigateToCurrent', {
							page: nextPage,
							route: route
						});
						App.log('next page is the current one');
						
					} else {
						
						App.modules.notify('pages.loading', {
							page: nextPage
						});
						
						App.modules.notify('pages.requestBeginPageTransition', {
							currentPage: currentPage,
							nextPage: nextPage,
							route: route
						});
						
						// Load from xhr or use cache copy
						if (!nextPage.loaded()) {
							// Raise the flag to mark we are in the process
							// of loading a new page
							mediatorIsLoadingPage = true;
							
							Loader.load({
								url: obj, // the *actual* route
								priority: 0, // now
								vip: true, // don't queue on fail
								success: loadSucess,
								progress: progress,
								error: function (e) {
									App.modules.notify('pages.loaderror', {
										event: e,
										url: obj
									});
								},
								giveup: function (e) {
									// Free the mediator
									mediatorIsLoadingPage = false;
									// Reset the current page
									
									App.log({args: 'Giving up!', me: 'Loader'});
									
									App.modules.notify('pages.loadfatalerror', {
										event: e,
										url: obj
									});
								}
							});
						} else {
							enterLeave();
							
							App.modules.notify('pages.loaded', {
								elem: $(ROOT),
								url: obj,
								page: nextPage
							});
						}
					}
				} else {
					App.log({args: ['Route "%s" is invalid.', obj], fx: 'error'});
				}
			}
		}
		return this;
	};
	
	/**
	 * Open the wanted page,
	 * return to the precedent page if the requested on is already open
	 * or fallback to a default one
	 * @name toggle
	 * @memberof App
	 * @method
	 * @fires App#page:toggleNoPreviousUrl
	 * @param {String} route Url
	 * @param {String} fallback Url used for as a fallback
	 * @public
	 */
	var togglePage = function (route, fallback) {
		if (!!currentPage &amp;&amp; _validateMediatorState()) {
			var
			nextPage = App.pages.getPageForRoute(route);
			
			if (_validateNextPage(nextPage) &amp;&amp; _canEnterNextPage(nextPage)) {
				if (nextPage !== currentPage) {
					gotoPage(route);
				} else if (!!previousUrl) {
					gotoPage(previousUrl);
				} else if (!!fallback) {
					gotoPage(fallback);
				} else {
					/**
					 * @event App#page:toggleNoPreviousUrl
					 * @type {object}
					 * @property {object} currentPage PageObject
					 */
					App.modules.notify('page.toggleNoPreviousUrl', { currentPage: nextPage });
				}
			}
		}
		return this;
	};
	
	/**
	 * Init All the applications
	 * Assign root variable
	 * Call init on all registered page and modules
	 * @name initApplication
	 * @memberof App
	 * @method
	 * @fires App#page:entering
	 * @fires App#page:enter
	 * @param {String} root CSS selector
	 * @private
	 */
	var initApplication = function (root) {
		
		// assure root node
		if (!!root &amp;&amp; !!$(root).length) {
			ROOT = root;
		}
		
		// init each Modules
		$.each(App.modules.models(), function _initModule () {
			this.init();
		});
		
		// init each Page already loaded
		$.each(App.pages.instances(), function _initPage () {
			if (!!this.loaded()) {
				// init page
				this.init({firstTime: true});
				this.isInited = true;
				
				// find if this is our current page
				// current route found ?
				if (!!~App.pages._matchRoute(currentRouteUrl, this.routes())) {
					// initialise page variable
					currentPage = this;
					previousPage = this; // Set the same for the first time
					/**
					 * @event App#page:entering
					 * @type {object}
					 * @property {Object} page PageObject
					 * @property {String} route Url
					 */
					App.modules.notify('page.entering', {
						page: currentPage,
						route: currentRouteUrl
					});
					// enter the page right now
					currentPage.enter(function _currentPageEnterCallback () {
						/**
						 * @event App#page:enter
						 * @type {object}
						 * @property {Object} page PageObject
						 * @property {String} route Url
						 */
						App.modules.notify('page.enter', {
							page: currentPage,
							route: currentRouteUrl
						});
					});
				}
			}
		});
		
		notifyAll('app.init', {
			page: currentPage
		});
	};
	
	/**
	 * Init the app with the given css selector
	 * @name run
	 * @memberof App
	 * @method
	 * @param {String=} root CSS selector
	 * @public
	 */
	var run = function (root) {
		initApplication(root);
		return App;
	};
	
	/** Public Interfaces **/
	global.App = $.extend(global.App, {
		// private
		_callAction: _callAction,
		
		// root node for the pages
		root: function () {
			return ROOT;
		},
		
		// main entrance
		run: run,
		
		// mediator object
		mediator: {
			// private
			_currentPage: function (page) {
				if (!!page) {
					currentPage = page;
				}
				return currentPage;
			},
			
			/**
			 * Get the currentPage object
			 * @name getCurrentPage
			 * @memberof App
			 * @method
			 * @returns {Object} PageObject
			 * @public
			 */
			getCurrentPage: function () {
				return currentPage;
			},
			
			// event dispatcher to the
			// current Page and Modules
			notify: notifyAll,
			
			// event dispatcher to the
			// current Page only
			notifyCurrentPage: notifyPage,
			
			// leave the current Page and
			// enter a new one, specified by the url
			goto: gotoPage,
			
			// toggle the requested page (may be enter or leave the requested page)
			//if leaving (already current page) then the previous page is using for the goto
			toggle: togglePage
		}
	});
	
})(jQuery, window);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Events</h3><ul><li><a href="App.html#event:page:enter">page:enter</a></li><li><a href="App.html#event:page:entering">page:entering</a></li><li><a href="App.html#event:page:leave">page:leave</a></li><li><a href="App.html#event:page:leaving">page:leaving</a></li><li><a href="App.html#event:page:toggleNoPreviousUrl">page:toggleNoPreviousUrl</a></li><li><a href="App.html#event:pages:failedtoparse">pages:failedtoparse</a></li><li><a href="App.html#event:pages:requestPageTransition">pages:requestPageTransition</a></li></ul><h3>Namespaces</h3><ul><li><a href="App.html">App</a></li><li><a href="App.callback.html">App.callback</a></li><li><a href="App.components.html">App.components</a></li><li><a href="App.debug.html">App.debug</a></li><li><a href="App.device.html">App.device</a></li><li><a href="App.modules.html">App.modules</a></li><li><a href="App.pages.html">App.pages</a></li><li><a href="Storage.html">Storage</a></li></ul><h3>Global</h3><ul><li><a href="global.html#pd">pd</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Jan 09 2018 16:46:50 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
